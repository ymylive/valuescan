"""
Performance Database Module for Trader Performance Tracking.

This module provides SQLite database operations for:
- Trade record storage and retrieval
- Trader management
- Performance data persistence

Requirements: 4.1, 4.2
"""

import sqlite3
from contextlib import contextmanager
from dataclasses import dataclass
from typing import Dict, List, Optional, Any
import json
import os
import time
from pathlib import Path


@dataclass
class TradeRecord:
    """
    Represents a single trade record.
    
    Attributes:
        id: Unique identifier (auto-generated by database)
        trader_id: Identifier of the trader/bot
        timestamp: Unix timestamp in milliseconds when trade occurred
        symbol: Trading pair symbol (e.g., 'BTCUSDT')
        side: Trade direction ('BUY' or 'SELL')
        quantity: Trade quantity
        price: Execution price
        realized_pnl: Realized profit/loss from this trade
        order_id: Optional exchange order ID
    """
    id: Optional[int]
    trader_id: str
    timestamp: int
    symbol: str
    side: str
    quantity: float
    price: float
    realized_pnl: float
    order_id: Optional[str] = None
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert TradeRecord to dictionary."""
        return {
            'id': self.id,
            'trader_id': self.trader_id,
            'timestamp': self.timestamp,
            'symbol': self.symbol,
            'side': self.side,
            'quantity': self.quantity,
            'price': self.price,
            'realized_pnl': self.realized_pnl,
            'order_id': self.order_id
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'TradeRecord':
        """Create TradeRecord from dictionary."""
        return cls(
            id=data.get('id'),
            trader_id=data.get('trader_id', 'default'),
            timestamp=data['timestamp'],
            symbol=data['symbol'],
            side=data['side'],
            quantity=float(data['quantity']),
            price=float(data['price']),
            realized_pnl=float(data['realized_pnl']),
            order_id=data.get('order_id')
        )
    
    def to_json(self) -> str:
        """Serialize TradeRecord to JSON string."""
        return json.dumps(self.to_dict())
    
    @classmethod
    def from_json(cls, json_str: str) -> 'TradeRecord':
        """Deserialize TradeRecord from JSON string."""
        return cls.from_dict(json.loads(json_str))


@dataclass
class Trader:
    """
    Represents a trader/bot configuration.
    
    Attributes:
        id: Unique identifier for the trader
        name: Display name
        description: Optional description
        created_at: Unix timestamp in milliseconds
    """
    id: str
    name: str
    description: Optional[str] = None
    created_at: Optional[int] = None
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert Trader to dictionary."""
        return {
            'id': self.id,
            'name': self.name,
            'description': self.description,
            'created_at': self.created_at
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Trader':
        """Create Trader from dictionary."""
        return cls(
            id=data['id'],
            name=data['name'],
            description=data.get('description'),
            created_at=data.get('created_at')
        )


class PerformanceDatabase:
    """
    SQLite database for trader performance tracking.
    
    Provides CRUD operations for:
    - Trade records
    - Trader configurations
    
    Requirements: 4.1, 4.2
    """
    
    def __init__(self, db_path: str = "performance.db"):
        """
        Initialize the database.
        
        Args:
            db_path: Path to SQLite database file
        """
        self.db_path = db_path
        self._init_schema()
    
    @contextmanager
    def _get_connection(self):
        """Get a database connection with context management."""
        conn = sqlite3.connect(self.db_path)
        conn.row_factory = sqlite3.Row
        try:
            yield conn
            conn.commit()
        except Exception:
            conn.rollback()
            raise
        finally:
            conn.close()
    
    def _init_schema(self):
        """Initialize database schema with trades and traders tables."""
        with self._get_connection() as conn:
            cursor = conn.cursor()
            
            # Create trades table
            # Requirements: 4.1 - Record trade details including timestamp, symbol,
            # side, quantity, price, and realized PnL
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS trades (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    trader_id TEXT NOT NULL DEFAULT 'default',
                    timestamp INTEGER NOT NULL,
                    symbol TEXT NOT NULL,
                    side TEXT NOT NULL,
                    quantity REAL NOT NULL,
                    price REAL NOT NULL,
                    realized_pnl REAL NOT NULL,
                    order_id TEXT,
                    created_at INTEGER DEFAULT (strftime('%s', 'now') * 1000)
                )
            """)
            
            # Create traders table
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS traders (
                    id TEXT PRIMARY KEY,
                    name TEXT NOT NULL,
                    description TEXT,
                    created_at INTEGER DEFAULT (strftime('%s', 'now') * 1000)
                )
            """)
            
            # Create indexes for efficient querying
            # Index on trader_id and timestamp for time-range queries per trader
            cursor.execute("""
                CREATE INDEX IF NOT EXISTS idx_trades_trader_timestamp 
                ON trades(trader_id, timestamp)
            """)
            
            # Index on timestamp for global time-range queries
            cursor.execute("""
                CREATE INDEX IF NOT EXISTS idx_trades_timestamp 
                ON trades(timestamp)
            """)
            
            # Insert default trader if not exists
            cursor.execute("""
                INSERT OR IGNORE INTO traders (id, name, description)
                VALUES ('default', '默认交易员', '系统默认交易机器人')
            """)
    
    # ========================================================================
    # Trade Record Operations
    # ========================================================================
    
    def save_trade(self, trade: TradeRecord) -> int:
        """
        Save a trade record to the database.
        
        Args:
            trade: TradeRecord to save
            
        Returns:
            The ID of the inserted trade record
            
        Requirements: 4.1
        """
        with self._get_connection() as conn:
            cursor = conn.cursor()
            
            cursor.execute("""
                INSERT INTO trades 
                (trader_id, timestamp, symbol, side, quantity, price, realized_pnl, order_id)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?)
            """, (
                trade.trader_id,
                trade.timestamp,
                trade.symbol,
                trade.side,
                trade.quantity,
                trade.price,
                trade.realized_pnl,
                trade.order_id
            ))
            
            return cursor.lastrowid
    
    def get_trade(self, trade_id: int) -> Optional[TradeRecord]:
        """
        Get a trade record by ID.
        
        Args:
            trade_id: The trade ID
            
        Returns:
            TradeRecord or None if not found
        """
        with self._get_connection() as conn:
            cursor = conn.cursor()
            
            cursor.execute(
                "SELECT * FROM trades WHERE id = ?",
                (trade_id,)
            )
            row = cursor.fetchone()
            
            if row:
                return TradeRecord(
                    id=row['id'],
                    trader_id=row['trader_id'],
                    timestamp=row['timestamp'],
                    symbol=row['symbol'],
                    side=row['side'],
                    quantity=row['quantity'],
                    price=row['price'],
                    realized_pnl=row['realized_pnl'],
                    order_id=row['order_id']
                )
            return None
    
    def get_trades(
        self,
        trader_id: Optional[str] = None,
        limit: int = 1000,
        offset: int = 0
    ) -> List[TradeRecord]:
        """
        Get trade records with optional filtering by trader.
        
        Args:
            trader_id: Filter by trader ID (optional)
            limit: Maximum number of results
            offset: Offset for pagination
            
        Returns:
            List of TradeRecord objects sorted by timestamp ascending
            
        Requirements: 4.2
        """
        with self._get_connection() as conn:
            cursor = conn.cursor()
            
            if trader_id:
                cursor.execute("""
                    SELECT * FROM trades 
                    WHERE trader_id = ?
                    ORDER BY timestamp ASC
                    LIMIT ? OFFSET ?
                """, (trader_id, limit, offset))
            else:
                cursor.execute("""
                    SELECT * FROM trades 
                    ORDER BY timestamp ASC
                    LIMIT ? OFFSET ?
                """, (limit, offset))
            
            trades = []
            for row in cursor.fetchall():
                trades.append(TradeRecord(
                    id=row['id'],
                    trader_id=row['trader_id'],
                    timestamp=row['timestamp'],
                    symbol=row['symbol'],
                    side=row['side'],
                    quantity=row['quantity'],
                    price=row['price'],
                    realized_pnl=row['realized_pnl'],
                    order_id=row['order_id']
                ))
            return trades
    
    def get_trades_by_range(
        self,
        start_time: int,
        end_time: int,
        trader_id: Optional[str] = None
    ) -> List[TradeRecord]:
        """
        Get trade records within a time range.
        
        Args:
            start_time: Start timestamp in milliseconds (inclusive)
            end_time: End timestamp in milliseconds (inclusive)
            trader_id: Filter by trader ID (optional)
            
        Returns:
            List of TradeRecord objects within the time range
            
        Requirements: 4.2
        """
        with self._get_connection() as conn:
            cursor = conn.cursor()
            
            if trader_id:
                cursor.execute("""
                    SELECT * FROM trades 
                    WHERE trader_id = ? AND timestamp >= ? AND timestamp <= ?
                    ORDER BY timestamp ASC
                """, (trader_id, start_time, end_time))
            else:
                cursor.execute("""
                    SELECT * FROM trades 
                    WHERE timestamp >= ? AND timestamp <= ?
                    ORDER BY timestamp ASC
                """, (start_time, end_time))
            
            trades = []
            for row in cursor.fetchall():
                trades.append(TradeRecord(
                    id=row['id'],
                    trader_id=row['trader_id'],
                    timestamp=row['timestamp'],
                    symbol=row['symbol'],
                    side=row['side'],
                    quantity=row['quantity'],
                    price=row['price'],
                    realized_pnl=row['realized_pnl'],
                    order_id=row['order_id']
                ))
            return trades
    
    def get_trade_count(self, trader_id: Optional[str] = None) -> int:
        """
        Get total count of trade records.
        
        Args:
            trader_id: Filter by trader ID (optional)
            
        Returns:
            Total number of trades
        """
        with self._get_connection() as conn:
            cursor = conn.cursor()
            
            if trader_id:
                cursor.execute(
                    "SELECT COUNT(*) as count FROM trades WHERE trader_id = ?",
                    (trader_id,)
                )
            else:
                cursor.execute("SELECT COUNT(*) as count FROM trades")
            
            return cursor.fetchone()['count']
    
    def delete_trade(self, trade_id: int) -> bool:
        """
        Delete a trade record.
        
        Args:
            trade_id: The trade ID to delete
            
        Returns:
            True if deleted, False if not found
        """
        with self._get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("DELETE FROM trades WHERE id = ?", (trade_id,))
            return cursor.rowcount > 0
    
    # ========================================================================
    # Trader Operations
    # ========================================================================
    
    def save_trader(self, trader: Trader) -> bool:
        """
        Save or update a trader.
        
        Args:
            trader: Trader to save
            
        Returns:
            True if saved successfully
        """
        with self._get_connection() as conn:
            cursor = conn.cursor()
            
            created_at = trader.created_at or int(time.time() * 1000)
            
            cursor.execute("""
                INSERT OR REPLACE INTO traders (id, name, description, created_at)
                VALUES (?, ?, ?, ?)
            """, (
                trader.id,
                trader.name,
                trader.description,
                created_at
            ))
            
            return True
    
    def get_trader(self, trader_id: str) -> Optional[Trader]:
        """
        Get a trader by ID.
        
        Args:
            trader_id: The trader ID
            
        Returns:
            Trader or None if not found
        """
        with self._get_connection() as conn:
            cursor = conn.cursor()
            
            cursor.execute(
                "SELECT * FROM traders WHERE id = ?",
                (trader_id,)
            )
            row = cursor.fetchone()
            
            if row:
                return Trader(
                    id=row['id'],
                    name=row['name'],
                    description=row['description'],
                    created_at=row['created_at']
                )
            return None
    
    def get_all_traders(self) -> List[Trader]:
        """
        Get all traders.
        
        Returns:
            List of all Trader objects
        """
        with self._get_connection() as conn:
            cursor = conn.cursor()
            
            cursor.execute("SELECT * FROM traders ORDER BY created_at ASC")
            
            traders = []
            for row in cursor.fetchall():
                traders.append(Trader(
                    id=row['id'],
                    name=row['name'],
                    description=row['description'],
                    created_at=row['created_at']
                ))
            return traders
    
    def delete_trader(self, trader_id: str) -> bool:
        """
        Delete a trader (does not delete associated trades).
        
        Args:
            trader_id: The trader ID to delete
            
        Returns:
            True if deleted, False if not found
        """
        with self._get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("DELETE FROM traders WHERE id = ?", (trader_id,))
            return cursor.rowcount > 0
    
    def get_trader_ids_with_trades(self) -> List[str]:
        """
        Get list of trader IDs that have at least one trade.
        
        Returns:
            List of trader IDs
        """
        with self._get_connection() as conn:
            cursor = conn.cursor()
            
            cursor.execute("""
                SELECT DISTINCT trader_id FROM trades ORDER BY trader_id
            """)
            
            return [row['trader_id'] for row in cursor.fetchall()]


# Global database instance (singleton pattern)
_db_instance: Optional[PerformanceDatabase] = None


def get_performance_db(db_path: str = "performance.db") -> PerformanceDatabase:
    """
    Get the global performance database instance.
    
    Args:
        db_path: Path to database file (only used on first call)
        
    Returns:
        PerformanceDatabase instance
    """
    global _db_instance
    if _db_instance is None:
        env_path = os.environ.get("VALUESCAN_PERFORMANCE_DB_PATH")
        if env_path:
            resolved = env_path
        else:
            repo_root = Path(__file__).resolve().parent.parent
            resolved = str(repo_root / db_path)
        _db_instance = PerformanceDatabase(resolved)
    return _db_instance


def reset_db_instance():
    """Reset the global database instance (useful for testing)."""
    global _db_instance
    _db_instance = None
